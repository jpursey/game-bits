#ifndef GB_BASE_CALLBACK_SCOPE_H_
#define GB_BASE_CALLBACK_SCOPE_H_

#include <memory>

#include "absl/synchronization/mutex.h"
#include "gb/base/callback.h"
#include "gb/base/weak_ptr.h"

namespace gb {

// A callback scope specifies a bounded lifetime for a callback to exist.
//
// All callbacks constructed through the CallbackScope will automatically become
// no-op callbacks when the CallbackScope is deleted. This allows safely
// generating callbacks to external whose lifetime is unknown or otherwise
// independent. A common use case for a CallbackScope is to safely wrap
// callbacks that bind to "this".
//
// This class is thread-compatible. However, callbacks generated by this scope
// can be called safely from any thread, as long as the callbacks themselves are
// thread-safe. If a scoped callback is executing, then CallbackScope will block
// in its destructor until the callback completes. As such, callbacks *must not*
// delete the underlying scope as a side-effect.
class CallbackScope final {
 public:
  CallbackScope() : scope_(this) {
    alive_ = scope_.GetWeakPtr<CallbackScope>();
  }
  CallbackScope(const CallbackScope&) = delete;
  CallbackScope& operator=(const CallbackScope&) = delete;

  // Callback destructor.
  //
  // This will block until there are no scoped callbacks executing.
  ~CallbackScope() {
    scope_.InvalidateWeakPtrs();
  }

  // Invalidates all callbacks for this scope.
  //
  // Any existing callbacks will become no-ops and all new callbacks created
  // after this is called will be no-ops.
  void InvalidateCallbacks() {
    scope_.InvalidateWeakPtrs();
  }

  // Creates a new void-return callback bound to this scope.
  //
  // When the scope is deleted, then the returned callback will do nothing.
  // Please see the class overview for thread safety details.
  template <typename Callable,
            typename = std::enable_if_t<std::is_same<
                void, typename Callback<Callable>::ReturnType>::value>>
  Callback<Callable> New(Callback<Callable> callback) {
    if (callback == nullptr) {
      return callback;
    }
    return Factory<Callable>::NewVoid(alive_, std::move(callback));
  }

  // Creates a new value-returning callback bound to this scope.
  //
  // When the scope is deleted, then the returned callback will return a default
  // value (which is the default-constructed return type, if not specified).
  // Please see the class overview for thread safety details.
  template <typename Callable,
            typename = std::enable_if_t<!std::is_same<
                void, typename Callback<Callable>::ReturnType>::value>>
  Callback<Callable> New(
      Callback<Callable> callback,
      typename Callback<Callable>::ReturnType default_value = {}) {
    if (callback == nullptr) {
      return callback;
    }
    return Factory<Callable>::NewDefault(
        alive_, std::move(callback), std::move(default_value));
  }

 private:
  WeakScope<CallbackScope> scope_;
  WeakPtr<CallbackScope> alive_;

  template <typename Callable>
  class Factory;

  template <typename Return, typename... Args>
  class Factory<Return(Args...)> {
   public:
    static Callback<void(Args...)> NewVoid(WeakPtr<CallbackScope> alive,
                                           Callback<Return(Args...)> callback) {
      return [alive = std::move(alive),
              callback = std::move(callback)](Args&&... args) {
        auto lock = alive.Lock();
        if (lock) {
          callback(std::forward<Args>(args)...);
        }
      };
    }
    template <
        typename DefaultType,
        typename = std::enable_if_t<!std::is_same<void, DefaultType>::value>>
    static Callback<Return(Args...)> NewDefault(
        WeakPtr<CallbackScope> alive, Callback<Return(Args...)> callback,
        DefaultType default_value) {
      return [alive = std::move(alive), callback = std::move(callback),
              default_value = std::move(default_value)](Args&&... args) {
        auto lock = alive.Lock();
        if (lock) {
          return callback(std::forward<Args>(args)...);
        }
        return default_value;
      };
    }
  };
};

}  // namespace gb

#endif  // GB_BASE_CALLBACK_SCOPE_H_
